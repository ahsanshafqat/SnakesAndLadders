I have used the Test Driven Development Test. That's writing the test which is failing, 
then writing the minimum amount of code to pass the test, then refactoring the code to make it better.
I considered using SOLID principles. I have created a class library project to write the domain-specific
code which has three main components Token, Dice and Player. Token component has a move method, 
which is used to move the space and property to identify the current location of Token.
Dice component has method roll which will generate a random number between 1 and 6, it also has a 
property name LastNumber which will have a value generated by calling roll method. Finally, the Player
component has two dependencies Dice and Token, using these dependencies player can roll dice as well as
move the token. it has a boolean property which will indicate the player has won or not after moving token.

I did not implement the dependency container, after implementing dependency container the solution does
not need to use the new keyword, in future this code can be used to play snakes and ladder game in real time,
because of the basic foundation provided the key components backed by unit tests, we can also introduce 
snakes, ladder and board components for full working game implementation. The board component can have multiple
players to play the game in real time.

The key point during the implementation was Dice and Token dependences injecting in Player Component because the Player has to play 
the game using these components.